# HashMap底层实现原理

- 数据结构: 数组 + 链表(1.8红黑树)

- Key不可重复

- 无序

- 默认容量 16

- 默认负载因子 0.75, 就是说当size到达12时, 会发生扩容, 扩容为原来的两倍

- 允许一个null key, null value会被覆盖

- 默认链表长度达到8 并且元素数量大于64时, 将链表结构转为红黑树

- 自定义类的对象如果作为key, 必须重写hashcode和equals


# 影响HashMap性能的重要参数

负载因子 默认 0.75

默认容量 默认 16

# HashMap扩容

![img](../../../assets/20200618150149962.png)
# 为什么HashMap的底层数组长度为何总是2的n次方

HashMap根据用户传入的初始化容量，利用无符号右移和按位或运算等方式计算出第一个大于该数的2的幂。

- 使数据分布均匀，减少碰撞

- 当length为2的N次方的时候，h & (length-1) = h % length, 相当于对length取模，而且在速度、效率上比直接取模要快得多

我们来举例当length为奇数、偶数时的情况：

![img](../../../assets/20200618150805100.png)

![img](../../../assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTQxNzcz,size_16,color_FFFFFF,t_70-20221229104123242.png)

从上面的图表中我们可以看到，当 length 为15时总共发生了8次碰撞，同时发现空间浪费非常大，因为在 1、3、5、7、9、11、13、15 这八处没有存放数据。

这是因为hash值在与14（即 1110）进行&运算时，得到的结果最后一位永远都是0，那么最后一位为1的位置即 0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的。这样，空间的减少会导致碰撞几率的进一步增加，从而就会导致查询速度慢。

而当length为16时，length – 1 = 15， 即 1111，那么，在进行低位&运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。所以，当 length=2^n 时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。

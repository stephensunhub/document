#  JVM结构

- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区
- 运行时常量池
- 直接内存



# 程序计数器

- 线程私有
- 控制代码流程, 如: **顺序执行, 选择, 循环, 异常处理**
- 在多线程情况下, 记录当前线程执行的位置, 如果线程被切换回来, 继续该位置执行
- 唯一不会出现OutOfMemoryError的区域
- 生命周期随着线程创建而创建, 随着线程结束而死亡

# 虚拟机栈

- 线程私有

- stackoverflowerror和outofmemoryerror

- 由一个一个栈帧组成

- 每个栈帧都拥有: **局部变量表, 操作数栈, 动态链接, 方法出口信息**

- 每次函数调用都会有一个对应的栈帧被压入虚拟机栈的栈顶, 函数结束后, 回被弹出

- 局部变量表用于存放方法的参数和方法内的局部变量

- 每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用, 在调用过程中会进行动态链接, 将这个符号引用转化为直接引用

  [^静态链接]: 部分符号引用会在类加载阶段转化为直接引用
  [^动态链接]: 部分符号引用会在运行时转化为直接引用

# 本地方法栈

- native方法
- 一般用c或c++
- 本地方法栈执行时也会在本地方法栈创建栈帧, 用于存放局部变量表, 操作数栈, 动态链接, 出口信息

# 堆

- 线程共享
- 用于存放对象实例
- 垃圾回收的主要区域, 因此也被称为gc堆, 细分为: **新生代(eden区, s0和s1), 老年代**

# 方法区

- 线程共享
- 存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据
- 对方法区的垃圾回收, 主要目标是**常量池的回收和对类的卸载**

## 永久代

- jdk1.7
- 方法区是jvm的规范, 而永久代PermGen是方法区的一种实现, 只有hotspot有永久代

## 元空间

- jdk1.8开始, 代替永久代
- 与永久代的区别: 元空间不在虚拟机中, 而是使用直接内存
- 永久代受限于jvm可用内存, 而元空间使用直接内存, 受本机内存限制

# 运行时常量池

- 方法区的一部分
- 类加载后, 会将编译器生成的各种字面量和符号引用放在运行时常量池

# 直接内存

- 不是虚拟机运行时内存的一部分, 也不是虚拟机规范定义的内存区域
- 读写操作比虚拟机内存快

# 堆栈区别

- 堆的物理地址不连续; 栈的物理地址分配连续, 栈的性能相对快
- 堆存放的是对象是实例和数组; 栈存放的是局部变量表, 操作数栈, 返回结果等
- 堆是线程共享; 栈是线程私有















